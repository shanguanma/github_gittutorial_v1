it is from /home4/md510/w2019a/kaldi-recipe/add-noise-to-seame/readme 
display lattice by pdf or svg

1. rnnlm rescoring lattice(call 2-pass , it(e.g.:dev_man) is based rnnlm decode) dispaly
# convert one lattice to a normal fst
. path.sh
lattice-lmrescore-kaldi-rnnlm-pruned --lm-scale=0.5 --bos-symbol=34798 --eos-symbol=34799 --brk-symbol=34800 --lattice-compose-beam=4 --acoustic-scale=0.1 --max-ngram-order=4 data/lang_test_pp/G.fst 'rnnlm-get-word-embedding exp/rnnlm/rnnlm_lstm_tdnn_1b/word_feats.txt exp/rnnlm/rnnlm_lstm_tdnn_1b/feat_embedding.final.mat -|' exp/rnnlm/rnnlm_lstm_tdnn_1b/final.raw 'ark:gunzip -c exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/decode_dev_man_better_pp/lat.1.gz|' 'ark,t:|gzip -c>test-one-lattice/dev_man/two-pass/lat.1.gz'

# draw svg from a fst, because the pdf format don't display Chinese. output path is test-one-lattice/dev_man/two-pass 
local/show_lattice.sh --output test-one-lattice/dev_man/two-pass --format svg --mode save --lm-scale 0.5 --acoustic-scale 0.1 nc12m-06nc12may_0101-00162-00459 test-one-lattice/dev_man/two-pass/lat.1.gz data/lang/words.txt

# display lattice by text , first column is Starting state of arc,second colum is ending state of arc, third colum is label(e.g. words id ) ,
# fourth colum is weigths(first is lm weigth and second is acoustic weigt third is transiton-id sequence)
gunzip -c exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/decode_dev_man_pp_lattice_rescore/lat.1.gz | less

2. decoder lattice (call 1-pass, it(test set) is based back-off n-gram decode) display
. path.sh
cp exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/decode_dev_man_better_pp/lat.1.gz test-one-lattice/dev_man/one-pass/
local/show_lattice.sh --output test-one-lattice/dev_man/one-pass --format svg --mode save  --acoustic-scale 10 nc12m-06nc12may_0101-00162-00459 test-one-lattice/dev_man/one-pass/lat.1.gz data/lang/words.txt


display lattice by text:come from:https://senarvi.github.io/kaldi-lattices/
1.rnnlm rescoring lattice(call 2-pass , its lattice is CompactLattice format, it(e.g.:dev_man) is based rnnlm decode) dispaly
. path.sh
# command form is as follows:
# lattice-copy "ark:zcat DECODE-DIR/lat.N.gz |" ark,t:- |
# utils/int2sym.pl -f 3 LANG-DIR/words.txt
lattice-copy "ark:gunzip -c  test-one-lattice/dev_man/two-pass/lat.1.gz |" ark,t:- | utils/int2sym.pl -f 3 data/lang_test_pp/words.txt | head -n 100
or
lattice-copy "ark:zcat test-one-lattice/dev_man/two-pass/lat.1.gz |" ark,t:- | utils/int2sym.pl -f 3 data/lang_test_pp/words.txt | less

#the output is  as follows:
##The firts line of the output contains the utterance ID. The following lines each contain start and end state, word, and a comma-separated list of weights. 
##If the lattice is in CompactLattice format, the weights include graph cost(actually it is main lm score),acoustic cost and transition IDs
#
## for example: in test-one-lattice/dev_man/two-pass/lat.1.gz, There are no transition IDs associated with the word "okay". This is because generally the weights are not synchronized with 
##each other and the word identities--it is only meaningful to look at a whole path from the initial node to the final node.
#
2. decoder lattice (call 1-pass,its lattice is CompactLattice format, it(test set) is based back-off n-gram decode) display
.path.sh
# command form is as follows:
# # lattice-copy "ark:zcat DECODE-DIR/lat.N.gz |" ark,t:- |
# # utils/int2sym.pl -f 3 LANG-DIR/words.txt
#
lattice-copy "ark:gunzip -c  test-one-lattice/dev_man/one-pass/lat.1.gz |" ark,t:- | utils/int2sym.pl -f 3 data/lang_test_pp/words.txt | head -n 100
or
lattice-copy "ark:zcat test-one-lattice/dev_man/one-pass/lat.1.gz |" ark,t:- | utils/int2sym.pl -f 3 data/lang_test_pp/words.txt | less
#the output is  as follows:
##The firts line of the output contains the utterance ID. The following lines each contain start and end state, word, and a comma-separated list of weights. 
##If the lattice is in CompactLattice format, the weights include graph cost(actually it is main lm score),acoustic cost and transition IDs
#
## for example: in test-one-lattice/dev_man/two-pass/lat.1.gz, There are no transition IDs associated with the word "okay". This is because generally the weights are not synchronized with 
##each other and the word identities--it is only meaningful to look at a whole path from the initial node to the final node.
#
3. align the transtion ID with word boundaries
# Often it is useful to align the transition IDs with word boundaries, so that one arc corresponds to one word, by calling lattice-align-words first.
# command form is as follows:
# lattice-align-words LANG-DIR/phones/word_boundary.int \
#                     MODEL-DIR/final.mdl \
#                    "ark:zcat DECODE-DIR/lat.N.gz |" ark,t:- |
#                   utils/int2sym.pl -f 3 LANG-DIR/words.txt

. path.sh
lattice-align-words data/lang_test_pp/phones/word_boundary.int exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/final.mdl "ark:zcat test-one-lattice/dev_man/two-pass/lat.1.gz |" ark,t:- | utils/int2sym.pl -f 3 data/lang_test_pp/words.txt | head -n 100
# the output is as follows:
# Now the output starts with some transitions that produce the <eps> token. 
# It is a special token meaning that there is no word on this arc. 
# The arcs correspond to the silence at the beginning of the utterance. The transition IDs on the other arcs correspond to the words.

4. decoding best path
# lattice-best-path is a simple utility to decode the best path of lattices and output word IDs. 
# A word symbol table can be provided for mapping the IDs to words, 
# but that affects the debug output only. In order to write text transcripts, 
# one can output in text format and convert the word IDs to words using int2sym.pl (excluding the first field, which is the utterance ID)
# command form is as follows:
# lattice-best-path --lm-scale=12 \
#                   --word-symbol-table=LANG-DIR/words.txt \
#                  "ark:zcat DECODE-DIR/lat.N.gz |" ark,t:- |
# utils/int2sym.pl -f 2- LANG-DIR/words.txt >transcript.ref
. path.sh
lattice-best-path --lm-scale=0.5 --acoustic-scale=0.1 --word-symbol-table=data/lang_test_pp/words.txt "ark:zcat test-one-lattice/dev_man/two-pass/lat.1.gz |" ark,t:- | utils/int2sym.pl -f 2- data/lang_test_pp/words.txt > test-one-lattice/dev_man/two-pass/transcript_best_path.hyp
5. decoding n-best path
# N-best list in Kaldi are represented as lattices with n distinct (linear) paths. 
# A lattice with n best paths can be decoded using lattice-nbest, 
# and the single best path can be decoded using lattice-1best. 
# Transition IDs, language model costs, acoustic costs, and transcripts can be extracted from linear FSTs using nbest-to-linear utility:
# command form is as follows:
# lattice-1best --lm-scale=12 \
#               "ark:zcat DECODE-DIR/lat.N.gz |" ark:- |
# nbest-to-linear ark:- \
#               ark,t:transition-ids.txt \
#               ark,t:- \
#               ark,t:lm-costs.txt \
#               ark,t:acoustic-costs.txt |
# utils/int2sym.pl -f 2- LANG-DIR/words.txt >transcript.ref
lattice-1best --lm-scale=0.5 --acoustic-scale=0.1 "ark:zcat test-one-lattice/dev_man/two-pass/lat.1.gz |" ark:- | nbest-to-linear ark:- ark,t:transition-ids.txt ark,t:- ark,t:lm-costs.txt ark,t:acoustic-costs.txt |utils/int2sym.pl -f 2- data/lang_test_pp/words.txt >test-one-lattice/dev_man/two-pass/transcript_1_best.hyp

6.decode n-best path to get CTM transcript
# A linear lattice can be converted into time marked CTM transcript using nbest-to-ctm, 
# which is useful if you need to know when each word was spoken. 
# First the lattice must be aligned with word boundaries. Again the word IDs (the fifth field) need to be converted to words.
# The CTM file will contain five fields on each line: utterance ID, audio channel, begin time in seconds, duration in seconds, and the word.
# command form is as follows:
# lattice-1best --lm-scale=12 \
#          "ark:zcat DECODE-DIR/lat.N.gz |" ark:- |
# lattice-align-words LANG-DIR/phones/word_boundary.int \
#              MODEL-DIR/final.mdl \
#              ark:- ark:- |
# nbest-to-ctm ark:- - |
# utils/int2sym.pl -f 5 LANG-DIR/words.txt >transcript.ctm
lattice-1best --lm-scale=0.5 --acoustic-scale=0.1 "ark:zcat test-one-lattice/dev_man/two-pass/lat.1.gz |" ark:- |lattice-align-words data/lang_test_pp/phones/word_boundary.int exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/final.mdl ark:- ark:- |nbest-to-ctm ark:- - |utils/int2sym.pl -f 5 data/lang_test_pp/words.txt >test-one-lattice/dev_man/two-pass/transcript_1_best.ctm

7.get 

# When optimizing the lattice size, it is helpful to know the oracle word error rate. 
# lattice-oracle computes the minimum error rate that can be obatined from the lattice, 
# in a similar way that can be done using the SRILM command lattice-tool -ref-file. 
# The command takes as input the lattice file and the reference transcript. 
# Transcripts are expected to be in form of utterance ID followed by word IDs, 
# so utils/sym2int.pl should be used to map the words to word IDs. Any out-of-vocabulary words in the reference transcripts need to be mapped to the [oov] tag first:
# command form is as follows:
# utils/sym2int.pl --map-oov [oov] -f 2- LANG-DIR/words.txt \
#                 <transcript.ref |
# lattice-oracle --word-symbol-table=LANG-DIR/words.txt \
#                "ark:zcat PRUNED-DIR/lat.N.gz |" \
#               ark:- \
#               ark,t:oracle-transcript.int




3. G.fst display
# output path must be /tmp.but run 22 hours ,hasn't result. I give up it.
#. path.sh
#fstdraw --portrait=true --osymbols=data/lang_test_pp/words.txt data/lang_test_pp/G.fst | dot -Tsvg >/tmp/G.svg
#cp /tmp/G.svg test-one-lattice/grammar/
# Gfst.txt is text form. Let me explain what each column means.
#
# first colum is start state, second colum is destination state, third colum is input lable on the arc, fourth column is output lable on the arc, fifth column is weigth (also called score,or cost).
# you can also see input lable equal output lable , so the G.fst is FSA form.
. path.sh
fstprint data/lang_test_pp/G.fst >Gfst.txt
fstinfo data/lang_test_pp/G.fst
fstdraw data/lang_test_pp/G.fst >L.dot

4. L.fst display
. path.sh
 fstinfo data/lang_test_pp/L.fst>Lfst.txt
fstinfo data/lang_test_pp/L.fst
fstdraw data/lang_test_pp/L.fst >L.dot
5. L_disambig.fst display 
# L_disambigfst.txt is text form.  Let me explain what each column means.
# From the information of fstinfo, first colum is start state, second colum is destination state,third colum is input lable on the arc, fourth column is output lable on the arc, fifth column is weigth (also called score,or cost). input lable don't equal output lable,so the L_disambig.fst is FST form. and type of L_disambig.fst is vector
#  
. path.sh
fstprint data/lang_test_pp/L_disambig.fst > L_disambigfst.txt
fstinfo data/lang_test_pp/L_disambig.fst 
fstdraw data/lang_test_pp/L_disambig.fst >L_disambig.dot
6. HCLG.fst display
# HCLGfst.txt is text form. Let me explain what each column means. 
# first colum is start state, second colum is destination state,third colum is input lable on the arc, fourth column is output lable on the arc, fifth column is weigth (also called score,or cost). input lable don't equal output lable,so the HCLG.fst is FST form. and type of L_disambig.fst is const
. path.sh 
fstprint exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/graph_better_pp/HCLG.fst>HCLGfst.txt
fstinfo exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/graph_better_pp/HCLG.fst     
fstdraw exp/chain_1a/tdnn_cnn_tdnnf_1a_sp/graph_better_pp/HCLG.fst > HCLG.dot

