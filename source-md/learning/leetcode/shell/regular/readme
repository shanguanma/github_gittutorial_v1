以下教程来自：http://cn.linux.vbird.org/linux_basic/0330regularex_2.php

1.搜寻特定字串很简单吧？假设我们要从刚刚的文件当中取得 the 这个特定字串，最简单的i方式就是这样：

grep -n 'the' regular_express.txt

2.那如果想要『反向选择』呢？也就是说，当该行没有 'the' 这个字串时才显示在萤幕上，那就直接使用
grep -vn 'the' regular_express.txt
3.接下来，如果你想要取得不论大小写的 the 这个字串，则：
grep -in 'the' regular_express.txt

4.如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 't?st' 存在～这个时候，我可以这样来搜寻：
grep -n 't[ae]st' regular_express.txt
5.了解了吧？其实 [] 里面不论有几个字节，他都谨代表某『一个』字节， 所以，上面的例子说明了，我需要的字串是『tast』或『test』两个字串而已！ 而如果想要搜寻到有 oo 的字节时，则使用：
grep -n 'oo' regular_express.txt
6.但是，如果我不想要 oo 前面有 g 的话呢？此时，可以利用在集合字节的反向选择 [^] 来达成：
grep -n '[^g]oo' regular_express.txt

2:apple is my favorite food.
3:Football game is not use feet only.
18:google is the best tools for search keyword.
19:goooooogle yes!

意思就是说，我需要的是 oo ，但是 oo 前面不能是 g 就是了！仔细比较上面两个表格，你会发现，第 1,9 行不见了，因为 oo 前面出现了 g 所致！第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！但是第 18 行明明有 google 的 goo 啊～别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～ 也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由於有需要的项目 (too) ， 因此，是符合字串搜寻的喔！

至於第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如： go(ooo)oogle ，所以，这一行也是符合需求的！

7.再来，假设我 oo 前面不想要有小写字节，所以，我可以这样写 [^abcd....z]oo ， 但是这样似乎不怎么方便，由於小写字节的 ASCII 上编码的顺序是连续的， 因此，我们可以将之简化为底下这样：
grep -n '[^a-z]oo' regular_express.txt
显示为：
3:Football game is not use feet only.
8.也就是说，当我们在一组集合字节中，如果该字节组是连续的，例如大写英文/小写英文/数字等等， 就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字串是数字与英文呢？ 呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]。例如，我们要取得有数字的那一行，就这样：
grep -n '[0-9]' regular_express.txt

9.但由於考虑到语系对於编码顺序的影响，因此除了连续编码使用减号『 - 』之外， 你也可以使用如下的方法来取得前面两个测试的结果：
grep -n '[^[:lower:]]oo' regular_express.txt # 那个 [:lower:] 代表的就是 a-z 的意思
显示为：
3:Football game is not use feet only.

10.行首与行尾字节 ^ $
我们在例题一当中，可以查询到一行字串里面有 the 的，那如果我想要让 the 只在行首列出呢？ 这个时候就得要使用定位字节了！我们可以这样做

grep -n '^the' regular_express.txt
显示为：
12:the symbol '*' is represented as start.
11.此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外， 如果我想要开头是小写字节的那一行就列出呢？可以这样：

grep -n '^[a-z]' regular_express.txt
12.那如果我不想要开头是英文字母，则可以是这样：

grep -n '^[^a-zA-Z]' regular_express.txt
或者用这个grep -n '^[^[:alpha:]]' regular_express.txt 

13.注意到了吧？那个 ^ 符号，在字节集合符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！
grep -n '\.$' regular_express.txt

14.哪一行是『空白行』， 也就是说，该行并没有输入任何数据，该如何搜寻？
grep -n '^$' regular_express.txt

15.
其中第一个『 -v '^$' 』代表『不要空白行』，
# 第二个『 -v '^#' 』代表『不要开头是 # 的那行』喔！
 grep -v '^$' regular_express.txt | grep -v '^#'


16.假设所有的数据都是一般文字 (这也是最常见的状态)，因此最常用来分隔数据的符号就是 [Tab] 啦！因为 [Tab] 按键可以将数据作个整齐的排列！那么如何利用 printf 呢？

将刚刚上头数据的文件 (printf.txt) 内容仅列出姓名与成绩：(用 [tab] 分隔)
printf '%s\t  %s\t %s\t %s\t %s\t \n' $(cat printf.txt)

17.您要輸入﹕
sed 1,3d src.file
所顯示的結果﹐就會將 src.file 的前面三行砍掉。如果您輸入﹕
sed '3,$d' src.file
這樣﹐所顯示的結果﹐就會從第 3 行到最後一行都砍掉﹐只剩下第 1 和第 2 行而已。 上面的命令別忘了加引號﹐否則要 \$ 來跳脫。不過﹐我強烈建議您用單引號將 sed 的命令括起來。如果您要將空白行拿掉﹐用 RE 來做非常簡單﹕
sed '/^$/d' src.file
在 sed 裡面引用 RE 的時候﹐ 通常都會用兩個 / / 符號將 RE 括起來﹐然後才是命令。 如果您想要更換字串﹐那就要用 s 命令了﹕
sed 's/red/blue/g' src.file
這樣﹐所有的 red 字串都會被換成 blue ﹔如果沒有加上 g 旗標﹐那麼只有每一行的第一個 red 被替換而已


18.这里重点说一下awk 用 -F 定義出分隔符号这里我用' '表示,所以$2表示文本的第二列的文本，是以空格作为分割符号的
ifconfig enp6s0 | grep "inet" | awk -F ' ' '{print $2}'


# delete special symbols
# note: 这个正则表达式很简单，只需要把你要删除的字符用|分开就行，这样可以同时删除多个字符，只是这样匹配多个字符时你需要用中括号把这些都括起来就好了．凡是用反斜杠来转义的字符通常在正则表达式中有特殊含义，所以如果真的想删除这样的符号，在这个字符前面加上反斜杠就可以了
sed --regexp-extended  's/[（|）/|；|？|，|%|>|=|％|丶|／|\•|。|\<s|！|\．|：|\‧|:|、|——|!|－|》|‘|──|\+|】|【|@|’|\●|∕|〈|〉|』|＂|\■|\·|℃|『|～|⊙|–|○|∶|\*|…|\＋]//g' ~/w2019a/leetcode/shell/regular/regular_express.txt

#note 因为这个字符比较特殊，如果放在上面会导致把文本中的空格也会删除，所以只能单独用这条命令来解决
删除字符ⅱ 
 sed 's/ⅱ //g' ~/w2019a/leetcode/shell/regular/regular_express.txt

